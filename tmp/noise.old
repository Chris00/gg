(*---------------------------------------------------------------------------
   Copyright (c) %%COPYRIGHTYEAR%%, Daniel C. Bünzli. All rights reserved.     
   Distributed under a BSD license, see ../../LICENSE.                  
  ---------------------------------------------------------------------------*)

let one_eps = 1. -. V1.zero_eps
let half_log = log 0.5

let bias b x = x ** (log b /. log 0.5)

let gain g x = 
  let p = log (1. -. g) /. half_log in
  if x < V1.zero_eps then 0. else 
  if x > one_eps then 1. else
  if x < 0.5 then ((2. *. x) ** p) /. 2. 
  else 1. -. ((2. *. (1. -. x)) ** p) /. 2.


(* Adapted from Ken Perlin's improved noise Java implementation *)
let p = [|                                 (* Random permutation of 0..255 *)
  151; 160; 137; 91; 90; 15; 131; 13; 201; 95; 96; 53; 194; 233; 7; 225; 140; 
  36; 103; 30; 69; 142; 8; 99; 37; 240; 21; 10; 23; 190;  6; 148; 247; 120; 
  234; 75; 0; 26; 197; 62; 94; 252; 219; 203; 117; 35; 11; 32; 57; 177; 33; 
  88; 237; 149; 56; 87; 174; 20; 125; 136; 171; 168;  68; 175; 74; 165; 71; 
  134; 139; 48; 27; 166; 77; 146; 158; 231; 83; 111; 229; 122; 60; 211; 133; 
  230; 220; 105; 92; 41; 55; 46; 245; 40; 244; 102; 143; 54;  65; 25; 63; 161;
  1; 216; 80; 73; 209; 76; 132; 187; 208;  89; 18; 169; 200; 196; 135; 130; 
  116; 188; 159; 86; 164; 100; 109; 198; 173; 186;  3; 64; 52; 217; 226; 250; 
  124; 123; 5; 202; 38; 147; 118; 126; 255; 82; 85; 212; 207; 206; 59; 227; 
  47; 16; 58; 17; 182; 189; 28; 42; 223; 183; 170; 213; 119; 248; 152; 2; 44; 
  154; 163;  70; 221; 153; 101; 155; 167;  43; 172; 9; 129; 22; 39; 253;  19; 
  98; 108; 110; 79; 113; 224; 232; 178; 185;  112; 104; 218; 246; 97; 228; 
  251; 34; 242; 193; 238; 210; 144; 12; 191; 179; 162; 241;  81; 51; 145; 235; 
  249; 14; 239; 107; 49; 192; 214;  31; 181; 199; 106; 157; 184;  84; 204; 176;
  115; 121; 50; 45; 127;  4; 150; 254; 138; 236; 205; 93; 222; 114; 67; 29; 24;
  72; 243; 141; 128; 195; 78; 66; 215; 61; 156; 180;
  (* Start again *)
  151; 160; 137; 91; 90; 15; 131; 13; 201; 95; 96; 53; 194; 233; 7; 225; 140; 
  36; 103; 30; 69; 142; 8; 99; 37; 240; 21; 10; 23; 190;  6; 148; 247; 120; 
  234; 75; 0; 26; 197; 62; 94; 252; 219; 203; 117; 35; 11; 32; 57; 177; 33; 
  88; 237; 149; 56; 87; 174; 20; 125; 136; 171; 168;  68; 175; 74; 165; 71; 
  134; 139; 48; 27; 166; 77; 146; 158; 231; 83; 111; 229; 122; 60; 211; 133; 
  230; 220; 105; 92; 41; 55; 46; 245; 40; 244; 102; 143; 54;  65; 25; 63; 161;
  1; 216; 80; 73; 209; 76; 132; 187; 208;  89; 18; 169; 200; 196; 135; 130; 
  116; 188; 159; 86; 164; 100; 109; 198; 173; 186;  3; 64; 52; 217; 226; 250; 
  124; 123; 5; 202; 38; 147; 118; 126; 255; 82; 85; 212; 207; 206; 59; 227; 
  47; 16; 58; 17; 182; 189; 28; 42; 223; 183; 170; 213; 119; 248; 152; 2; 44; 
  154; 163;  70; 221; 153; 101; 155; 167;  43; 172; 9; 129; 22; 39; 253;  19; 
  98; 108; 110; 79; 113; 224; 232; 178; 185;  112; 104; 218; 246; 97; 228; 
  251; 34; 242; 193; 238; 210; 144; 12; 191; 179; 162; 241;  81; 51; 145; 235; 
  249; 14; 239; 107; 49; 192; 214;  31; 181; 199; 106; 157; 184;  84; 204; 176;
  115; 121; 50; 45; 127;  4; 150; 254; 138; 236; 205; 93; 222; 114; 67; 29; 24;
  72; 243; 141; 128; 195; 78; 66; 215; 61; 156; 180;
|]

let pc = "\                                 (* Random permutation of 0..255 *)
  \151\160\137\091\090\015\131\013\201\095\096\053\194\233\007\
  \225\140\036\103\030\069\142\008\099\037\240\021\010\023\190\ 
  \006\148\247\120\234\075\000\026\197\062\094\252\219\203\117\
  \035\011\032\057\177\033\088\237\149\056\087\174\020\125\136\
  \171\168\068\175\074\165\071\134\139\048\027\166\077\146\158\
  \231\083\111\229\122\060\211\133\230\220\105\092\041\055\046\
  \245\040\244\102\143\054\065\025\063\161\001\216\080\073\209\
  \076\132\187\208\089\018\169\200\196\135\130\116\188\159\086\
  \164\100\109\198\173\186\003\064\052\217\226\250\124\123\005\
  \202\038\147\118\126\255\082\085\212\207\206\059\227\047\016\
  \058\017\182\189\028\042\223\183\170\213\119\248\152\002\044\
  \154\163\070\221\153\101\155\167\043\172\009\129\022\039\253\ 
  \019\098\108\110\079\113\224\232\178\185\112\104\218\246\097\
  \228\251\034\242\193\238\210\144\012\191\179\162\241\081\051\
  \145\235\249\014\239\107\049\192\214\031\181\199\106\157\184\ 
  \084\204\176\115\121\050\045\127\004\150\254\138\236\205\093\
  \222\114\067\029\024\072\243\141\128\195\078\066\215\061\156\
  \180\
  \151\160\137\091\090\015\131\013\201\095\096\053\194\233\007\
  \225\140\036\103\030\069\142\008\099\037\240\021\010\023\190\ 
  \006\148\247\120\234\075\000\026\197\062\094\252\219\203\117\
  \035\011\032\057\177\033\088\237\149\056\087\174\020\125\136\
  \171\168\068\175\074\165\071\134\139\048\027\166\077\146\158\
  \231\083\111\229\122\060\211\133\230\220\105\092\041\055\046\
  \245\040\244\102\143\054\065\025\063\161\001\216\080\073\209\
  \076\132\187\208\089\018\169\200\196\135\130\116\188\159\086\
  \164\100\109\198\173\186\003\064\052\217\226\250\124\123\005\
  \202\038\147\118\126\255\082\085\212\207\206\059\227\047\016\
  \058\017\182\189\028\042\223\183\170\213\119\248\152\002\044\
  \154\163\070\221\153\101\155\167\043\172\009\129\022\039\253\ 
  \019\098\108\110\079\113\224\232\178\185\112\104\218\246\097\
  \228\251\034\242\193\238\210\144\012\191\179\162\241\081\051\
  \145\235\249\014\239\107\049\192\214\031\181\199\106\157\184\ 
  \084\204\176\115\121\050\045\127\004\150\254\138\236\205\093\
  \222\114\067\029\024\072\243\141\128\195\078\066\215\061\156\
  \180"



let perlin1 x = failwith "TODO"
let perlin2 x y = failwith "TODO"
let perlin3 x y z = 
(*  let fade c = c *. c *. (3. -. 2. *. c) in *)
  let fade c = c *. c *. c *. (c *. (c *. 6. -. 15.) +. 10.) in
  let lerp t a b = a +. t *. (b -. a) in
  let grad hash x y z = 
    let h = hash land 0b1111 in
    let u = if h < 8 then x else y in
    let v = if h < 4 then y else if h = 12 || h = 14 then x else z in
    (if (h land 1) = 0 then u else -. u) +. (if (h land 2) = 0 then v else -. v)
  in 
  let xi = truncate x land 255 in 
  let yi = truncate y land 255 in 
  let zi = truncate z land 255 in
  let xf = x -. floor x in
  let yf = y -. floor y in
  let zf = z -. floor z in
  let u = fade xf in
  let v = fade yf in
  let w = fade zf in
  let a = p.(xi) + yi in
  let aa = p.(a) + zi in
  let ab = p.(a + 1) + zi in
  let b = p.(xi + 1) + yi in
  let ba = p.(b) + zi in
  let bb = p.(b + 1) + zi in
  lerp w 
    (lerp v 
       (lerp u 
	  (grad p.(aa) xf yf zf) 
	  (grad p.(ba) (xf -. 1.) yf zf))
       (lerp u 
	  (grad p.(ab) xf (yf -. 1.) zf) 
	  (grad p.(bb) (xf -. 1.) (yf -. 1.) zf)))
    (lerp v 
       (lerp u 
	  (grad p.(aa + 1) xf yf (zf -. 1.)) 
	  (grad p.(ba + 1) (xf -. 1.) yf (zf -. 1.)))
       (lerp u 
	  (grad p.(ab + 1) xf (yf -. 1.) (zf -. 1.)) 
	  (grad p.(bb + 1) (xf -. 1.) (yf -. 1.) (zf -. 1.))))

let perlin4 x y z w = failwith "TODO"
let simplex1 x = failwith "TODO"
let simplex2 x y = failwith "TODO"


let one_div_3 = 1.0 /. 3.0
let one_div_6 = 1.0 /. 6.0

let gsimplex grad x y z =
  let iof = int_of_float in
  let n h x y z = 
    let t = 0.6 -. x *. x -. y *. y -. z *. z in
    if t < 0. then 0. else
    let t = t *. t in
    t *. t *. (grad h x y z)
  in
  let s = (x +. y +. z) *. one_div_3 in
  let i = floor (x +. s) in
  let j = floor (y +. s) in
  let k = floor (z +. s) in
  let t = (i +. j +. k) *. one_div_6 in
  let xi = i -. t in
  let yi = j -. t in
  let zi = k -. t in
  let x0 = x -. xi in
  let y0 = y -. yi in
  let z0 = z -. zi in
  let i1, j1, k1, i2, j2, k2 = 
    if x0 >= y0 then 
      if y0 >= z0 then 1., 0., 0., 1., 1., 0. else 
      if x0 >= z0 then 1., 0., 0., 1., 0., 1. else
      0., 0., 1., 1., 0., 1.
    else
      if y0 < z0 then 0., 0., 1., 0., 1., 1. else
      if x0 < z0 then 0., 1., 0., 0., 1., 1. else
      0., 1., 0., 1., 1., 0.
  in
  let x1 = x0 -. i1 +. one_div_6 in
  let y1 = y0 -. j1 +. one_div_6 in
  let z1 = z0 -. k1 +. one_div_6 in
  let x2 = x0 -. i2 +. one_div_3 in
  let y2 = y0 -. j2 +. one_div_3 in
  let z2 = z0 -. k2 +. one_div_3 in
  let x3 = x0 -. 0.5 in
  let y3 = y0 -. 0.5 in
  let z3 = z0 -. 0.5 in
  let i = (iof i) land 255 in
  let j = (iof j) land 255 in
  let k = (iof k) land 255 in
  let h0 = p.(i + p.(j + p.(k))) mod 12 in
  let h1 = p.(i + (iof i1) + p.(j + (iof j1) + p.(k + (iof k1)))) mod 12 in
  let h2 = p.(i + (iof i2) + p.(j + (iof j2) + p.(k + (iof k2)))) mod 12 in
  let h3 = p.(i + 1 + p.(j + 1 + p.(k + 1))) mod 12 in
  let n0 = n h0 x0 y0 z0 in
  let n1 = n h1 x1 y1 z1 in
  let n2 = n h2 x2 y2 z2 in
  let n3 = n h3 x3 y3 z3 in
  32. *. (n0 +. n1 +. n2 +. n3) 

let simplex3 x y z = 
  let grad hash x y z = 
    let h = hash land 0b1111 in
    let u = if h < 8 then x else y in
    let v = if h < 4 then y else if h = 12 || h = 14 then x else z in
    (if (h land 1) = 0 then u else -. u) +. (if (h land 2) = 0 then v else -. v)
  in
  gsimplex grad x y z
  

let simplex4 x y z w = failwith "TODO"

let olano1 x = failwith "TODO"
let olano2 x y = failwith "TODO"
let olano3 x y z = failwith "TODO"
let olano4 x y z w = failwith "TODO"

module V = struct
  let perlin1 = perlin1
  let perlin2 v = perlin2 (V2.x v) (V2.y v)
  let perlin3 v = perlin3 (V3.x v) (V3.y v) (V3.z v)
  let perlin4 v = perlin4 (V4.x v) (V4.y v) (V4.z v) (V4.w v)

  let simplex1 = simplex1
  let simplex2 v = simplex2 (V2.x v) (V2.y v)
  let simplex3 v = simplex3 (V3.x v) (V3.y v) (V3.z v)
  let simplex4 v = simplex4 (V4.x v) (V4.y v) (V4.z v) (V4.w v)

  let olano1 = olano1
  let olano2 v = olano2 (V2.x v) (V2.y v)
  let olano3 v = olano3 (V3.x v) (V3.y v) (V3.z v)
  let olano4 v = olano4 (V4.x v) (V4.y v) (V4.z v) (V4.w v)
end



